"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const Utils_1 = require("../../Utils");
const ASTTraverse_1 = require("../../ASTTraverse");
const ImportDeclaration_1 = require("../../analysis/plugins/ImportDeclaration");
let babel7Core;
class Babel7PluginClass {
    constructor(opts) {
        this.extensions = [".js", ".jsx", ".ts", ".tsx"];
        this.test = /\.(j|t)s(x)?$/;
        this.limit2project = true;
        this.configPrinted = false;
        this.configLoaded = false;
        this.configRequired = {
            ast: true,
            code: true,
            babelrc: false,
            configFile: false,
            sourceType: "module",
            filenameRelative: "",
            root: "",
        };
        this.config = Object.assign({}, this.configRequired);
        if (typeof opts === "object" &&
            opts.config === undefined &&
            opts.test === undefined &&
            opts.limit2project === undefined &&
            opts.extensions === undefined &&
            opts.configFile === undefined &&
            Object.keys(opts).length) {
            Object.assign(this.config, opts, this.configRequired);
            return;
        }
        if (typeof opts === "object" && opts !== null) {
            if (opts.limit2project) {
                this.limit2project = !!opts.limit2project;
            }
            if (opts.test) {
                this.test = opts.test;
            }
            if (opts.extensions) {
                this.extensions = opts.extensions;
                if (opts.test === undefined) {
                    this.test = Utils_1.string2RegExp(opts.extensions.join("|"));
                }
            }
            if (opts.config) {
                if (typeof opts.config !== "object") {
                    throw new Error("Babel7Plugin - `config` property must be null | undefined | plain object");
                }
                Object.assign(this.config, opts.config, this.configRequired);
            }
            if (opts.configFile) {
                this.configFile = opts.configFile;
            }
        }
        else if (opts !== null || opts !== undefined) {
            throw new Error(`Babel7Plugin - Invalid options provided.`);
        }
    }
    loadOptionsAndValidate() {
        if (this.configLoaded)
            return;
        if (typeof this.configFile === "undefined" || this.configFile === null || this.configFile === true) {
            this.configFile = [
                path.join(this.context.homeDir, ".babelrc"),
                path.join(this.context.homeDir, "babel.config.js"),
            ].find(path => {
                if (fs.existsSync(path))
                    return true;
                return false;
            });
        }
        else if (typeof this.configFile === "string") {
            const configPath = path.join(this.context.homeDir, this.configFile);
            if (!fs.existsSync(configPath)) {
                throw new Error(`Babel7Plugin - configuration file not found on path ${configPath}`);
            }
            this.configFile = configPath;
        }
        if (typeof this.configFile === "string") {
            let configFileContents;
            const ext = path.extname(this.configFile);
            if (ext === "" || ext === ".json") {
                configFileContents = JSON.parse(fs.readFileSync(this.configFile).toString());
            }
            else if ([".js", ".jsx", ".mjs", ".ts", ".tsx"].includes(ext)) {
                configFileContents = require(this.configFile);
                if (typeof configFileContents !== "object") {
                    throw new Error("Babel7Plugin - your configuration file must have an object as default export./n	e.g: module.exports = { presets: ['@babel/preset-env'] }");
                }
            }
            configFileContents.filenameRelative = this.context.homeDir;
            const partialConfig = babel7Core.loadPartialConfig(configFileContents);
            Object.assign(this.config, partialConfig.options, this.config);
        }
        this.config.root = this.context.homeDir;
        this.config.filenameRelative = this.context.homeDir;
        this.config = babel7Core.loadOptions(this.config);
        this.configLoaded = true;
    }
    init(context) {
        try {
            babel7Core = require("@babel/core");
        }
        catch (error) {
            if (error.code === "MODULE_NOT_FOUND") {
                const message = "Babel7Plugin - requires @babel/core to be installed";
                throw new Error(message);
            }
            throw error;
        }
        this.context = context;
        if (Array.isArray(this.extensions)) {
            this.extensions.forEach(ext => context.allowExtension(ext));
        }
        this.loadOptionsAndValidate();
    }
    transform(file) {
        file.wasTranspiled = true;
        if (this.configPrinted === false && this.context.doLog === true) {
            file.context.debug("Babel7Plugin", `\n\tConfiguration: ${JSON.stringify(this.config, null, 2)}`);
            this.configPrinted = true;
        }
        if (this.context.useCache) {
            if (file.loadFromCache()) {
                return;
            }
        }
        file.loadContents();
        if (this.limit2project === false || file.collection.name === file.context.defaultPackageName) {
            const fileConfig = Object.assign({ filename: file.relativePath }, this.config);
            let result;
            try {
                result = babel7Core.transformSync(file.contents, fileConfig);
            }
            catch (e) {
                file.analysis.skip();
                this.context.log.error(e);
                return;
            }
            if (result.ast) {
                ASTTraverse_1.ASTTraverse.traverse(result.ast, {
                    pre: (node, parent, prop, idx) => ImportDeclaration_1.ImportDeclaration.onNode(file, node, parent),
                });
                ImportDeclaration_1.ImportDeclaration.onEnd(file);
                file.analysis.loadAst(result.ast);
                let sourceMaps = result.map;
                file.context.setCodeGenerator(ast => {
                    const result = babel7Core.transformFromAstSync(ast, void 0, Object.assign({ filename: file.relativePath }, this.config));
                    sourceMaps = result.map;
                    return result.code;
                });
                file.contents = result.code;
                file.analysis.analyze();
                if (sourceMaps) {
                    sourceMaps.file = file.info.fuseBoxPath;
                    sourceMaps.sources = [file.context.sourceMapsRoot + "/" + file.info.fuseBoxPath];
                    if (!file.context.inlineSourceMaps) {
                        delete sourceMaps.sourcesContent;
                    }
                    file.sourceMap = JSON.stringify(sourceMaps);
                }
                if (this.context.useCache) {
                    this.context.emitJavascriptHotReload(file);
                    this.context.cache.writeStaticCache(file, file.sourceMap);
                }
            }
        }
    }
}
exports.Babel7PluginClass = Babel7PluginClass;
exports.Babel7Plugin = (opts = {}) => {
    return new Babel7PluginClass(opts);
};
