import { WorkFlowContext } from "./WorkflowContext";
import { ScriptTarget } from "./File";
import * as ts from "typescript";
/**
 * Typecheck custom tsconfig provided as array.
 * It's Compiler options but replaced enums to equivalent strings keys
 * as it'd be seen in a `tsconfig.json` file
 * Check `typescript.d.ts`:
 * - `CompilerOptionsValue`
 * - `CompilerOptions`
 * e.g:
 * - Instead of `target: 1`, user can input `target: 'ES5'`
 */
export declare type rawScriptTarget = Exclude<keyof typeof ts.ScriptTarget, "JSON" | "Latest">;
export declare type rawCompilerOptions = {
    [key in keyof ts.CompilerOptions]: key extends "maxNodeModuleJsDepth" ? number : ts.CompilerOptions[key] extends ts.ScriptTarget ? rawScriptTarget : ts.CompilerOptions[key] extends ts.JsxEmit ? "react" | "preserve" | "react-native" : ts.CompilerOptions[key] extends ts.ModuleKind ? keyof typeof ts.ModuleKind : ts.CompilerOptions[key] extends ts.ModuleResolutionKind ? keyof typeof ts.ModuleResolutionKind : ts.CompilerOptions[key] extends ts.NewLineKind ? "CRLF" | "LF" : ts.CompilerOptions[key] extends ts.MapLike<string[]> ? ts.MapLike<string[]> : ts.CompilerOptions[key] extends string[] ? string[] : ts.CompilerOptions[key] extends string ? ts.CompilerOptions[key] : ts.CompilerOptions[key] extends boolean ? ts.CompilerOptions[key] : ts.CompilerOptions[key] extends number ? number : any;
};
export declare function getScriptLevelNumber(level: any): ScriptTarget & number | undefined;
export declare function getScriptLevelString(level: any): rawScriptTarget | undefined;
export interface ICategorizedDiagnostics {
    errors: ReadonlyArray<ts.Diagnostic & {
        category: ts.DiagnosticCategory.Error;
    }>;
    warnings: ReadonlyArray<ts.Diagnostic & {
        category: ts.DiagnosticCategory.Warning;
    }>;
    messages: ReadonlyArray<ts.Diagnostic & {
        category: ts.DiagnosticCategory.Message;
    }>;
    suggestions: ReadonlyArray<ts.Diagnostic & {
        category: ts.DiagnosticCategory.Suggestion;
    }>;
}
export interface TSParsedConfig {
    errors: Array<ts.Diagnostic | ts.DiagnosticWithLocation> | ts.SortedReadonlyArray<ts.Diagnostic>;
    compilerOptions: ts.CompilerOptions;
    compileOnSave?: boolean;
    projectReferences?: ReadonlyArray<ts.ProjectReference>;
    raw?: rawCompilerOptions;
    typeAcquisition?: ts.TypeAcquisition;
    wildcardDirectories?: ts.MapLike<ts.WatchDirectoryFlags>;
}
export declare const IGNORED_DIAGNOSTICS: Set<number>;
export declare function makePathDoesNotExistDiagnostic(path: string): ts.Diagnostic;
export declare class TypescriptConfig {
    context: WorkFlowContext;
    private config;
    private customTsConfig;
    private configFile;
    private formatDiagnosticsHost;
    private baseURLAutomaticAlias;
    constructor(context: WorkFlowContext);
    getConfig(): TSParsedConfig;
    normalizeDiagnostics(diagnostics: ts.Diagnostic[]): ts.SortedReadonlyArray<ts.Diagnostic>;
    private findConfigFileBackwards;
    readJsonConfigFile(): TSParsedConfig;
    private defaultSetup;
    forceCompilerTarget(level: ScriptTarget): void;
    setConfigFile(customTsConfig: string | rawCompilerOptions[]): void;
    private initializeConfig;
    private verifyTsLib;
    categorizeDiagnostics(diagnostics: ReadonlyArray<ts.Diagnostic> | Readonly<ts.Diagnostic>): ICategorizedDiagnostics;
    formatDiagnostic(diagnostic: ts.Diagnostic, separator?: boolean): string;
    logDiagnosticsByCategory(diagnostics: ReadonlyArray<ts.Diagnostic>, category: ts.DiagnosticCategory): void;
    logAllDiagnostics(diagnostics: ReadonlyArray<ts.Diagnostic>): void;
    throwOnDiagnosticErrors(diagnostics: ReadonlyArray<ts.Diagnostic>): never | void;
    read(): void;
}
