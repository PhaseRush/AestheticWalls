"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const Utils_1 = require("../Utils");
const File_1 = require("./File");
const fs = require("fs");
const Config_1 = require("../Config");
const ts = require("typescript");
const CACHED = {};
function getScriptLevelNumber(level) {
    if (Number.isNaN(Number(level)) && typeof level === "string") {
        const key = Object.keys(File_1.ScriptTarget)
            .filter(k => !["json", "latest"].includes(k.toLowerCase()))
            .find(t => t.toLowerCase() === level.toLowerCase());
        return key ? File_1.ScriptTarget[key] : undefined;
    }
    if (Number(level) in File_1.ScriptTarget && File_1.ScriptTarget.JSON !== Number(level)) {
        return Number(level);
    }
}
exports.getScriptLevelNumber = getScriptLevelNumber;
function getScriptLevelString(level) {
    if (Number(level) in File_1.ScriptTarget) {
        const key = Object.keys(File_1.ScriptTarget)
            .filter(k => !["json", "latest"].includes(k.toLowerCase()))
            .find(t => File_1.ScriptTarget[t] === Number(level));
        return key;
    }
}
exports.getScriptLevelString = getScriptLevelString;
exports.IGNORED_DIAGNOSTICS = new Set([
    6059,
    18002,
    18003,
]);
function makePathDoesNotExistDiagnostic(path) {
    return {
        code: 5058,
        category: ts.DiagnosticCategory.Error,
        messageText: `The specified path does not exist: '${path}'.`,
        file: undefined,
        length: undefined,
        start: undefined,
    };
}
exports.makePathDoesNotExistDiagnostic = makePathDoesNotExistDiagnostic;
class TypescriptConfig {
    constructor(context) {
        this.context = context;
        this.formatDiagnosticsHost = {
            getCanonicalFileName: file => file,
            getCurrentDirectory: () => context.homeDir,
            getNewLine: () => ts.sys.newLine,
        };
    }
    getConfig() {
        this.read();
        return this.config;
    }
    normalizeDiagnostics(diagnostics) {
        return ts.sortAndDeduplicateDiagnostics(diagnostics.filter(x => !exports.IGNORED_DIAGNOSTICS.has(x.code)));
    }
    findConfigFileBackwards(tsConfigFilePath) {
        return Utils_1.findFileBackwards(tsConfigFilePath, this.context.appRoot);
    }
    readJsonConfigFile() {
        const config = { compilerOptions: {}, errors: [] };
        this.configFile =
            typeof this.customTsConfig === "string"
                ? Utils_1.ensureUserPath(this.customTsConfig)
                : this.findConfigFileBackwards(path.join(this.context.homeDir, "tsconfig.json"));
        if (this.configFile) {
            if (!ts.sys.fileExists(this.configFile)) {
                config.errors = [makePathDoesNotExistDiagnostic(this.configFile)];
                return config;
            }
            const configFileRelPath = this.configFile.replace(this.context.appRoot, "");
            this.context.log.echoInfo(`Typescript config file:  ${configFileRelPath}`);
            const JSONSourceFile = ts.readJsonConfigFile(this.configFile, ts.sys.readFile);
            const parsedJSONFile = ts.parseConfigFileTextToJson(this.configFile, JSONSourceFile.getFullText());
            if (parsedJSONFile.error) {
                config.errors = [parsedJSONFile.error];
                return config;
            }
            if (parsedJSONFile.config && parsedJSONFile.config.compilerOptions) {
                this.baseURLAutomaticAlias = parsedJSONFile.config.compilerOptions.baseUrl === ".";
            }
            const parsedJSONConfigFile = ts.parseJsonSourceFileConfigFileContent(JSONSourceFile, ts.sys, path.dirname(this.configFile));
            if (parsedJSONConfigFile.errors.length) {
                const errors = this.normalizeDiagnostics(parsedJSONConfigFile.errors);
                if (errors.length) {
                    config.errors = errors;
                    return config;
                }
            }
            Object.assign(config, {
                compilerOptions: parsedJSONConfigFile.options,
                compileOnSave: parsedJSONConfigFile.compileOnSave,
                projectReferences: parsedJSONConfigFile.projectReferences,
                raw: parsedJSONConfigFile.raw,
                typeAcquisition: parsedJSONConfigFile.typeAcquisition,
                wildcardDirectories: parsedJSONConfigFile.wildcardDirectories,
            });
        }
        if (Array.isArray(this.customTsConfig)) {
            const tsConfigOverrideCompilerOptions = {};
            this.customTsConfig.forEach(config => {
                if (typeof config === "object" && config !== null) {
                    Object.assign(tsConfigOverrideCompilerOptions, config);
                }
                else {
                }
            });
            const parsedVirtualJSONConfig = ts.convertCompilerOptionsFromJson(tsConfigOverrideCompilerOptions, config.compilerOptions.baseUrl || ".", "");
            const virtualJSONSourceFile = ts.parseJsonText("[FuseBoxOptions.tsConfig]", JSON.stringify(this.customTsConfig));
            const errors = this.normalizeDiagnostics(parsedVirtualJSONConfig.errors);
            if (errors.length) {
                const flattenError = errors[0];
                flattenError.file = virtualJSONSourceFile;
                flattenError.start = 0;
                flattenError.length = virtualJSONSourceFile.getFullText().length;
                for (let i = 1; i < errors.length; i++) {
                    const error = errors[i];
                    flattenError.messageText += "\n" + this.formatDiagnostic(error, false);
                }
                config.errors = [flattenError];
                return config;
            }
        }
        config.compilerOptions.module = ts.ModuleKind.CommonJS;
        if (!("target" in config.compilerOptions)) {
            config.compilerOptions.target = this.context.languageLevel;
        }
        if (config.compilerOptions.allowSyntheticDefaultImports !== undefined &&
            this.context.fuse &&
            this.context.fuse.producer) {
            this.context.fuse.producer.allowSyntheticDefaultImports = config.compilerOptions.allowSyntheticDefaultImports;
        }
        return config;
    }
    defaultSetup() {
        const compilerOptions = (this.config.compilerOptions = this.config.compilerOptions || {});
        if (this.configFile && path.basename(this.configFile).startsWith("jsconfig.")) {
            compilerOptions.allowJs = true;
        }
        compilerOptions.sourceMap = this.context.useSourceMaps;
        compilerOptions.inlineSources = this.context.useSourceMaps;
        if (this.context.forcedLanguageLevel) {
            this.forceCompilerTarget(this.context.forcedLanguageLevel);
        }
        if (this.baseURLAutomaticAlias && this.context.automaticAlias) {
            let aliasConfig = {};
            let log = [];
            fs.readdirSync(this.context.homeDir).forEach(file => {
                if (file[0] === ".") {
                    return;
                }
                const extension = path.extname(file);
                if (!extension || extension === ".ts" || extension === ".tsx") {
                    let name = file;
                    if (extension) {
                        name = file.replace(/\.tsx?/, "");
                    }
                    log.push(`\t${name} => "~/${name}"`);
                    aliasConfig[name] = `~/${name}`;
                }
            });
            this.context.log.echoInfo(`Applying automatic alias based on baseUrl in tsconfig.json`);
            this.context.log.echoInfo(`\n ${log.join("\n")}`);
            this.context.addAlias(aliasConfig);
        }
    }
    forceCompilerTarget(level) {
        this.context.log.echoInfo(`Typescript forced script target: ${getScriptLevelString(level)}`);
        const compilerOptions = (this.config.compilerOptions = this.config.compilerOptions || {});
        compilerOptions.target = level;
    }
    setConfigFile(customTsConfig) {
        this.customTsConfig = customTsConfig;
    }
    initializeConfig() {
        if (!this.configFile && this.context.ensureTsConfig === true) {
            Object.assign(this.config.compilerOptions, {
                jsx: ts.JsxEmit.React,
                baseUrl: ".",
                importHelpers: true,
                emitDecoratorMetadata: true,
                experimentalDecorators: true,
            });
            const compilerOptions = Object.assign({}, this.config.compilerOptions, {
                target: getScriptLevelString(this.config.compilerOptions.target),
                module: "CommonJS",
                jsx: "react",
            });
            const targetFile = path.join(this.context.homeDir, "tsconfig.json");
            this.context.log.echoInfo(`Generating recommended tsconfig.json:  ${targetFile}`);
            fs.writeFileSync(targetFile, JSON.stringify({ compilerOptions }, null, 2));
        }
    }
    verifyTsLib() {
        if (this.context.ensureTsConfig === true && this.config.compilerOptions.importHelpers === true) {
            const tslibPath = path.join(Config_1.Config.NODE_MODULES_DIR, "tslib");
            if (!fs.existsSync(tslibPath)) {
                this.context.log.echoWarning(`You have enabled importHelpers. Please install tslib - https://github.com/Microsoft/tslib`);
            }
        }
    }
    categorizeDiagnostics(diagnostics) {
        const errors = [];
        const warnings = [];
        const messages = [];
        const suggestions = [];
        const diagnosticsArray = Array.isArray(diagnostics) ? diagnostics : [diagnostics];
        const size = diagnosticsArray.length;
        for (let i = 0; i < size; i++) {
            const diagnostic = diagnosticsArray[i];
            switch (diagnostic.category) {
                case ts.DiagnosticCategory.Error: {
                    errors.push(diagnostic);
                    break;
                }
                case ts.DiagnosticCategory.Warning: {
                    warnings.push(diagnostic);
                    break;
                }
                case ts.DiagnosticCategory.Message: {
                    messages.push(diagnostic);
                    break;
                }
            }
        }
        return { errors, warnings, messages, suggestions };
    }
    formatDiagnostic(diagnostic, separator = true) {
        diagnostic.messageText = `${diagnostic.messageText}\n`;
        const formatted = ts
            .formatDiagnosticsWithColorAndContext([diagnostic], this.formatDiagnosticsHost)
            .replace(/error|warning|message/, match => match.toUpperCase())
            .replace(/ - /, "\n")
            .split("\n")
            .filter(m => String(m).trim().length)
            .map((line, i) => (i === 0 ? line : separator ? `  │ ${line}` : line))
            .join("\n");
        return formatted;
    }
    logDiagnosticsByCategory(diagnostics, category) {
        if (diagnostics.length) {
            const size = diagnostics.length;
            for (let i = 0; i < size; i++) {
                const diagnosticMsg = this.formatDiagnostic(diagnostics[i]);
                switch (category) {
                    case ts.DiagnosticCategory.Error: {
                        this.context.log.echoRed(`  → ${diagnosticMsg}`);
                        break;
                    }
                    case ts.DiagnosticCategory.Warning: {
                        this.context.log.echoYellow(`  → ${diagnosticMsg}`);
                        break;
                    }
                    case ts.DiagnosticCategory.Message: {
                        this.context.log.echoBlue(`  → ${diagnosticMsg}`);
                        break;
                    }
                }
            }
        }
    }
    logAllDiagnostics(diagnostics) {
        const categorizedDiagnostics = this.categorizeDiagnostics(diagnostics);
        this.logDiagnosticsByCategory(categorizedDiagnostics.messages, ts.DiagnosticCategory.Message);
        this.logDiagnosticsByCategory(categorizedDiagnostics.warnings, ts.DiagnosticCategory.Warning);
        this.throwOnDiagnosticErrors(categorizedDiagnostics.errors);
    }
    throwOnDiagnosticErrors(diagnostics) {
        if (diagnostics.length) {
            this.logDiagnosticsByCategory(diagnostics, ts.DiagnosticCategory.Error);
            let errorMessage = `  └─ Invalid 'compilerOptions'`;
            this.context.log.echoBoldRed(`${errorMessage}\n`);
            process.exit(1);
        }
    }
    read() {
        const cacheKey = (typeof this.customTsConfig === "string" ? this.customTsConfig : this.context.homeDir) +
            this.context.target +
            this.context.languageLevel;
        if (CACHED[cacheKey]) {
            this.config = CACHED[cacheKey];
            return;
        }
        const config = this.readJsonConfigFile();
        if (config.errors.length) {
            this.logAllDiagnostics(config.errors);
            return process.exit(1);
        }
        this.config = config;
        this.defaultSetup();
        this.initializeConfig();
        this.verifyTsLib();
        this.context.log.echoInfo(`Typescript script target: ${getScriptLevelString(config.compilerOptions.target)}`);
        CACHED[cacheKey] = this.config;
    }
}
exports.TypescriptConfig = TypescriptConfig;
