"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sourceMap = require("source-map");
const FlatNode_1 = require("./FlatNode");
class Blender {
    constructor(input) {
        this.input = input;
        if (typeof input.originalMap === "string") {
            this.input.originalMap = JSON.parse(input.originalMap);
        }
    }
    async blend(opts) {
        opts = opts || {};
        let code = this.input.modifiedCode;
        const newMap = await this.start();
        if (opts.sourceMappingURL) {
            if (opts.sourceMappingURL === true) {
                code += `\n//# sourceMappingURL=module.js.map`;
            }
            else {
                code += `\n//# sourceMappingURL=${opts.sourceMappingURL}`;
            }
        }
        return {
            map: newMap,
            code: code
        };
    }
    async start() {
        const modifiedAst = this.input.parse(this.input.modifiedCode);
        this.flat = new FlatNode_1.FlatNodes(this.input.originalAST, modifiedAst);
        return await this.consumeSourceMaps();
    }
    async consumeSourceMaps() {
        const SourceMapConsumer = sourceMap.SourceMapConsumer;
        const SourceMapGenerator = sourceMap.SourceMapGenerator;
        const data = [];
        let map, sourceName;
        let newSourceMap;
        let newSourceName = this.input.sourceName;
        await SourceMapConsumer.with(this.input.originalMap, null, consumer => {
            sourceName = consumer.sources[0];
            if (!newSourceName) {
                newSourceName = sourceName;
            }
            map = new SourceMapGenerator({
                file: newSourceName
            });
            map.setSourceContent(newSourceName, consumer.sourceContentFor(sourceName)),
                this.flat.eachOriginalNode((original, modified) => {
                    let isStart = true;
                    let sm = consumer.originalPositionFor({
                        ...original.loc.start
                    });
                    if (!sm) {
                        isStart = false;
                        sm = consumer.originalPositionFor({
                            ...original.loc.end
                        });
                    }
                    if (sm && modified) {
                        if (sm.line) {
                            map.addMapping({
                                generated: {
                                    line: isStart ? modified.loc.start.line : modified.loc.end.line,
                                    column: isStart ? modified.loc.start.column : modified.loc.end.column
                                },
                                source: newSourceName,
                                original: {
                                    line: sm.line,
                                    column: sm.column
                                }
                            });
                        }
                    }
                    consumer.destroy();
                });
            newSourceMap = map.toString();
        });
        return newSourceMap;
    }
}
exports.Blender = Blender;
