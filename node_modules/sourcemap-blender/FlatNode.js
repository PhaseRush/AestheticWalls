"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
class FlatNodes {
    constructor(original, modified) {
        this.original = [];
        this.modified = [];
        this.generate(original, modified);
    }
    eachOriginalNode(fn) {
        let successIndex = 0;
        this.original.forEach((item, index) => {
            const found = this.modified.find((mod, index) => {
                if (mod.relativeId === item.relativeId && index >= successIndex) {
                    successIndex = index;
                    return true;
                }
                return false;
            });
            fn(item, found);
        });
    }
    prepareNode(node) {
        const args = [];
        let i = 0;
        if (node.object)
            args.push("a");
        if (node.callee)
            args.push("b");
        if (node.body)
            args.push("c");
        if (node.property)
            args.push("d");
        if (node.arguments)
            args.push("f");
        if (node.kind)
            args.push("g");
        if (node.method)
            args.push("h");
        if (node.shorthand)
            args.push("i");
        if (node.computed)
            args.push("g");
        if (node.expression)
            args.push("k");
        if (node.type)
            args.push(`l:${node.type}`);
        if (node.$prop)
            args.push(`m:${node.$prop}`);
        if (node.value) {
            args.push(`n${typeof node.value === "string" ? `:${node.value}` : ""}`);
        }
        if (typeof node.name === "string") {
            args.push(`o:${node.name}`);
        }
        else {
            args.push(`o`);
        }
        if (typeof node.kind === "string") {
            args.push(`p:${node.kind}`);
        }
        if (node.directive) {
            args.push(`r${typeof node.directive === "string" ? `:${node.directive}` : ""}`);
        }
        const relativeID = utils_1.fastHash(args.join(":"));
        return {
            relativeId: relativeID,
            type: node.type,
            loc: node.loc
        };
    }
    generate(ast1, ast2) {
        utils_1.visit(ast1, node => {
            this.original.push(this.prepareNode(node));
        });
        utils_1.visit(ast2, node => {
            this.modified.push(this.prepareNode(node));
        });
    }
}
exports.FlatNodes = FlatNodes;
